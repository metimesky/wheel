> 本页面规定 Wheel 在编写过程中需要遵循的规则，以及编码中的一些约定。

# 代码文件组织结构

编写 Wheel 的过程中，我曾多次改变代码文件的组织方式。虽然文件组织方式和 OS 的功能并无过多关系，但我希望 Wheel 的代码用一种清晰的方式组织起来，这样整个系统的架构会更加清晰，管理也更方便。

操作系统是一个复杂的东西，内部组件的耦合度很高，不能很容易地分解成若干独立组件。目前的代码组织方式可能只是暂时的，今后的某个版本可能还会重新组织，但至少，目前的组织方式是目前我认为最合适的。

## 目录结构

首先最外层，是目录 `kernel` 和 `docs`，用于保存内核代码与文档。当 Wheel 支持用户程序之后，还会加入 `user` 目录。除了这两个目录，还有一些说明和脚本文件。由于目前的 Wheel 只有内核部分，所以所有当前代码都在 `kernel` 目录下。

内核使用 C 语言和汇编写成，在文件组织上尽可能的模块化。目前的结构如下：

```
kernel/
├── drivers/
│   ├── acpi/
│   ├── apic/
│   ├── console/
│   ├── hpet/
│   ├── pic/
│   ├── pit/
│   └── serial/
├── init/
├── interrupt/
├── memory/
├── scheduler/
├── timming/
└── utilities/
```

某些 OS 项目有一个 `include` 目录，所有的头文件都放在里面。Wheel 没有这样的设计，所有的头文件都和源文件放在一起，整体的结构使用模块来组织（后面会专门介绍模块化与面向对象）。

`init` 是内核最初开始运行的部分，`boot.asm`、`multiboot.h` 和 `init.c` 就放在这里。

`interrupt` 是管理中断处理的模块，但是具体的中断处理是由其他模块完成的（例如页错误就是由内存管理器处理），因此 interrupt 模块的功能就是提供一个统一的框架，其他模块可以注册中断处理函数。

`memory` 是内存管理器，包括物理内存管理和虚拟内存管理，分别使用伙伴算法和 SLUB 算法实现。

`scheduler` 是内核的调度器，与进程相关，负责响应时钟中断。调度器同时负责实现同步互斥功能，例如信号量、互斥锁、自旋锁。

`timming` 是提供响应计时功能的模块（TODO：由调度程序提供）。计时的硬件驱动由其他模块实现，该模块只提供一个统一的框架。

`utilities` 是相关工具，里面有几个独立的头文件，包含编译器的 freestanding 环境，和 Wheel 自己实现的相关 C 标准库函数。

以上结构并不是固定的，随着开发可能发生改动。

## 模块化

OS 是非常复杂的，OS 的复杂性不仅体现在内容之多，也体现在极高的内部耦合性。长期以来的 OS 研究确定下来一些相对稳定的模块，例如内存管理、进程管理等，使得 OS 有了一定的结构。

将 OS 设计模块化非常有吸引力，这样可以让 OS 的组织结构变得非常清晰。Wheel 采用模块化设计内核，从上面的源代码结构中就可以看出，Wheel 的每个模块都是源代码中的一个目录，这个目录里面有模块自身的头文件和源代码。模块有明确定义的接口，这些接口就是头文件中定义的公开的函数，可以被其他模块使用。

与应用软件一样，模块的公开部分保持稳定，改变函数的内部实现，不会影响整个系统的运行。因此这种模块化设计可以有效地降低 OS 的耦合度。

在命名上，每个模块公开的函数都以该模块的名字开头。

模块也有粒度，最小粒度的模块就是两个文件，一个 `*.c` 文件，一个 `*.h` 文件。这种最小粒度的模块的接口定义在头文件里，包括函数原型和外部变量。实现位于 C 源文件里，模块的内部函数和内部变量在 C 源文件中，使用 `static` 前缀以避免符号被编译器导出。

有些模块中，需要定义一些类型、宏。使用 `typedef` 定义的类型放在头文件中，即使私有类型也这样（？），使用 `#define` 定义的宏如果仅限内部使用，则放在 C 语言源文件中。

编译的时候，保证头文件的最小化可以加快编译速度，如果宏的使用仅限 C 文件，则完全可以放在 C 文件内部。

命名的时候，所有的函数名都已模块的名字开头，以表明这是模块的成员函数。模块的初始化函数统一命名为 `<模块名>_init`，这个函数只能调用一次。如果模块需要多次初始化，例如 IO APIC，则在 init 函数中只进行基本的操作，之后使用 `io_apic_add` 函数来添加。

至于私有的函数和变量，命名上并没有严格的要求，很多时候都与共有对象规范一致。其实不区分公有私有也没什么不好的，Python 就是这样设计的。

## 面向对象

Wheel 使用 C 语言，但这并不妨碍采用面向对象的设计思想。许多内核对象的设计都采用了面向对象的思路。例如，信号量、进程体等数据结构，它们有自身的数据，同时也有一组函数专门用于操作这些数据。

# 代码风格

## 命名

Wheel 的变量/函数命名风格模仿 Linux，使用完整的单词，全小写，单词之间使用下划线连接。对于类型，使用 `_t` 结尾。

对于常量，使用全大写的完整单词，单词之间同样使用下划线连接。

代码文件名全小写，C 语言源程序的后缀名 `*.c`，头文件后缀 `*.h`，汇编文件后缀 `*.asm`。

对于 C 语言头文件，使用 Define-Guard 保护其中的内容。头文件只包含声明，所有的实现都写在 C 或汇编语言源文件里。

## 缩进、换行与空白

缩进使用 4 个空格，没有不能超过 80 列的限制，但是过长的行最好折行显示。

所有的大括号都写在同一行，起始大括号之前加一个空格。其他风格类似 Java。

## 类型系统

Wheel 使用 C 语言编译器的 freestanding 头文件，其中有标准整数类型的定义，如 `int32_t`、`uint64_t` 等。在内核中，优先使用这些类型表示整数，因为能直观地看出占用多少字节的存储空间。

## 例外情况

ACPI 驱动使用第三方模块 ACPICA 实现，因此其中的代码不遵循以上规则。由于 Wheel 只是使用 ACPICA，并不会对 ACPICA 的代码进行大改，因此这种不一致的风格并没有太坏的影响。
