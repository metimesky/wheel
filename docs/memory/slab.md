# 虚拟内存管理

Wheel 的内存管理分为两层，底层是屋里内层管理，单位是页。上层是虚拟内层管理，提供任意大小的 object 的分配。需要注意的是，通常 OS 中用户层和内核层使用两种不同的虚拟内存管理器，本文只关心内核中的虚拟内存管理。

形象地说，虚拟内存管理就是提供 malloc 和 free 这样的功能。Wheel 的内核虚拟内存管理主要参照 SLUB 的设计。每一次 malloc 和 free 的对象叫做一个对象，对象有不同的类型，在 Wheel 中只根据不同的大小区分对象类型。每一种对象类型都有一串 slab，用单链表组织起来。每个 slab 都是若干连续的页（有多少个连续的页是固定的，虽然不同类型对象的 slab 可能不同），每个 slab 中都包含若干连续分布的对象，因此对象的地址是按照对象大小对齐的。在 slab 的尾部，可能存在一些对齐的字节，Wheel 使用 slab 最后的几个字节存储 slab 链表中下一个元素的位置、当前 slab 可用对象数量。由于页的大小是 4K 对齐的，因此下一个 slab 的地址的最后 12 位是零。每个 slab 最多有 512 个元素（最小分配单元为 8 字节），因此可以将这两个信息放在同一个 uint64_t 字段之中。

## Slab 分配器

Wheel 实现了一种基于 Slab 的内存分配器，本质上学习的是 Linux 下的 SLUB（SLUB 是一种 Slab 实现）。内核动态分配的对象可能有多种大小，Slab 将相同大小的对象放在一个页里，这个页称作一个 Slab。Slab 中未分配的对象形成一个单链表，叫做 `free_list`，当某个 Slab 中所有对象都已分配后，就创建一个新的 Slab。也就是说，对于一种大小的对象，可能有多个 Slab，这些 Slab 同样用链表组织，乘坐 Bin。

## Wheel 内核的虚拟地址空间布局

首先给出 Wheel 内核的虚拟地址空间布局图：

```
0      1MB                4GB
+------+--------+---------+-----------+------------
| BASE | KERNEL | padding | KHeapMeta | KHeap -->
+------+--------+---------+-----------+------------
```

BASE 是 1M 以下的内存，Wheel 不去使用，KERNEL 是内核代码、数据，包括管理物理内存用的 buddy，都属于这一块。KHeap 是最后一部分，为内核堆空间。在内核堆与内核之间，是一段内核堆的元数据区。内核堆创建有多个 slab，每个 slab 都是一个页，并且 slab 之间组织成链表，因此需要 prev、next 指针等信息。这些信息乘坐 slab 元数据，为了保持 slab 结构简单，元数据放在单独的区域，那就是 KHeapMeta。根据一个 slab 的地址，能算出这个 slab 在 KHeap 中的下标，根据这个下标就能对应到 KHeapMeta 中。KHeapMeta 是一个大数组，每个元素都是 `struct slab` 类型的，就像在 Linux 的 `struct page` 一样，只不过这里只存和 slab 相关的信息。

内核初始化的时候，会根据系统最大可用内存计算内核堆的上限，也就能算出最多需要多少 slab，也就能够算出KHeapMeta 的数组长度的上限，于是就能算出内核堆的起始地址。运行过程中，内核还要记录内核堆的最后一个虚拟页的虚拟地址，因为这也是 KHeapMeta 中最后一个元素的位置，标记着 KHeapMeta 的已使用范围。对于已使用的 KHeapMeta，内核需要为其分配物理页，当创建新的 slab 导致内核堆扩张，KHeapMeta 数组已用部分增长，内核就（可能）要给 KHeapMeta 分配新的物理页，而内核堆使用量还比较小的时候，虽然 KHeapMeta 占用的空间固定，但是并不需要为其分配真正地物理页，同样能够起到节省内存的作用。

内核堆与内核堆元数据区是按需分配的。虽然它们的位置在启动时已经确定，但由于这时虚拟地址空间，不一定一开始就需要那么多物理页。在系统运行过程中，随着需求增长，在按需分配更多的物理页。

## 值得改进之处

是否有必要限制内核堆的最大大小？

目前实现的 Slab 分配器对于大对象的处理不好，利用内存不是十分高效。

