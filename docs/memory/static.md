# 静态内存分配

这里说的“静态”，不等于 C 语言的 static 变量，虽然意思有几分相似。这里说的静态内存分配，指的是分配了就不回收的资源，例如 IDT、TSS 等。可能会有疑问，如果这些资源申请之后就不可能释放，那么为什么不直接用全局变量，编译时就预留空间。原因就是，在内核编译的时候，需要多少空间往往是不确定的。就像 TSS 这种数据结构，在多核环境下，每个核都有一个，因此就只有在运行的时候才知道需要多少。受其影响，GDT 中需要多少个 TSS 的描述符就不确定，只有 OS 启动之后，从 ACPI 中读出了核芯数量，才能知道自己需要多少。

另一个例子，就是物理内存管理中的 buddy 算法，里面用到了一组位图，这个位图中每个位表示物理内存中的一个页帧，因此整个位图的总大小就取决于物理内存容量。

总之，有许多资源，我们希望像全局变量那样静态分配，但是受限于硬件，只有启动之后才知道需要申请多少。于是我在 Wheel 中加入了静态内存分配的机制。

由于静态内存分配非常原始，它只能在内核启动的时候使用。这也是静态分配的原理决定的。当内核被加载到内存的时候，占据了一定的内存空间，内核的加载位置和大小是可知的，因此内核能知道自己的结束位置。内核占用的部分作为已用内存，剩下的部分就是可用内存，内存管理器就来管理剩下的内存。如果要静态分配一部分内存，就直接将内核后面的一部分内存标记为已用，只需要记住当前用了多少就可以。

这样，就把内存管理分成了两个阶段，“公元前”阶段只能用静态分配，“公元后”阶段有了动态内存，只能用动态内存分配，因此在其他模块的初始化过程中，必须明确自己应该在哪个阶段初始化，该使用静态分配还是动态分配。

在动态内存初始化之前，内核需要将所有需要静态分配的资源分配好。这可能会影响到其他模块的初始化过程，因为一直以来希望实现的模块化就是为了降低耦合度，如果硬性区分静态分配和动态分配之后，其他模块就要受内存管理的影响而进行调整。不过这也是没办法的事情，操作系统本来就比较复杂，而且内存管理也算是核心的模块了，因此让其他模块迁就 memory 模块也算情理之中。

### 关于多核

引入多核之后，内存管理部分也许要大改。但是静态分配器由于非常原始，基本上就是启动过程中一个临时阶段，所有的静态分配都由 BSP 进行调用。
