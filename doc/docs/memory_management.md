## 分页

内存管理的硬件支持是分页机制。在 64 位模式下，分页是强制的，而且是 PAE 分页，PAE 分页意味着支持 2MB 大小的页。

在操作系统启动过程中，切换 64 位模式是最先执行的动作。因此在内存管理模块未启动的时候就需要建立分页。

## 初始分页

初始分页就是在切换64位模式的时候制定的分页映射。虽然当内存管理模块初始化之后可以改变页表，但是 Wheel 创建的初始分页是不变的。

首先需要明确内核的虚拟地址空间结构。64 位 CPU 使用的虚拟地址称作 Canonical Address Form，将完整的 52 位空间分成高低两个部分，更高位是符号扩展。

内核首先建立 0~4GB 的对等映射，也就是内核虚拟地址空间中，0~4GB 映射到 0~4GB 的物理内存。因为许多内存映射设备都处在物理地址 3~4GB 处，而且 52 位的线性地址空间足够使用，并且对等映射非常方便。这部分的映射在切换 64 位方式的时候设置，作为内核的初始分页。

## 请页和映射

要实现动态内存管理，必须要有内存申请和释放的办法。在最下层，内存是按照页为单位进行申请和释放的，内存管理器对新申请的内存页建立映射，将其映射到内核虚拟地址空间中，并建立相关数据结构来管理内存，向其他模块提供 `malloc` 和 `free` 函数的实现。

因此内存分配器底层使用到的 OS 支持是请页和映射。高层提供动态大小区块的申请和释放。

由于内核地址空间中前 4GB 已经映射到物理地址，新申请的物理页只能映射到 4GB 以上的地址。通常，动态扩展的部分称作堆。用户进程的堆是可以动态增长的，但是内核堆是固定的（？）。

## 物理页管理——伙伴算法

伙伴算法也是 Linux 用来物理页的算法，基本思想是相邻的块合并，这样可分配的大小都是 2 的整数次幂。

实现伙伴算法的关键是位图数据结构的支持。Wheel 中，通用的工具函数和数据结构/算法的代码放在 `library` 目录下，实现位图的代码在 `bitmap.{c,h}` 中。
